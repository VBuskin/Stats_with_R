---
title: "Summary statistics: Theory and practice"
author: Vladimir Buskin
format:
  html:
    self-contained: false
    theme: default
    toc: true
    number-sections: true
    slide-number: true
    incremental: false
    slide-level: 3
    scrollable: true
editor: visual
bibliography: R.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE
)
```

## Measures of central tendency {.scrollable}

```{r, echo = FALSE, output = FALSE}

# Libraries
library("readxl")
library("tidyverse")
library("ggthemes")

# Load data from working directory
cl.order <- read_xlsx("Paquot_Larsson_2020_data.xlsx")

```

### The mean {.smaller .scrollable}

-   A useful summary statistic is the arithmetic mean $\bar{x}$ [cf.
    @heumann_introduction_2022: 38]. Consider a variable $X$ with
    observations $x_1, x_2, ..., x_n$ from a sample of size $n$. The
    sample mean then corresponds to

    $$
    \bar{x}= \frac{x_1 + x_2 + ... + x_n}{n} \\ = \frac{1}{n}\sum_{i=1}^n{x_i}.
    $$

In R, we can obtain the average value of a numeric vector with the
`mean()` function.

```{r, echo = TRUE, output = TRUE}
# Using mean()
mean(cl.order$LEN_MC)

# or by hand:
mean <- 1/length(cl.order$LEN_MC) * sum(cl.order$LEN_MC)

```

**Visualisation**:

::: panel-tabset
#### Histogram

```{r, echo = TRUE, warnings = FALSE, message = FALSE}

# Plot distribution of LEN_MC
cl.length.hist <- ggplot(cl.order, aes(x = LEN_MC)) +
                  geom_histogram(binwidth = 2)

cl.length.hist +
  # Add mean
  geom_vline(aes(xintercept = mean(LEN_MC)),
             color = "steelblue",
             linewidth = 1) +
  theme_classic()
  
```

#### Density plot

```{r, echo = TRUE, warnings = FALSE, message = FALSE}

# Plot distribution of LEN_MC
cl.length.dens <- ggplot(cl.order, aes(x = LEN_MC)) +
                  geom_density()

cl.length.dens +
  # Add mean
  geom_vline(aes(xintercept = mean(LEN_MC)),
             color = "steelblue",
             linewidth = 1) +
  theme_classic()
  
```
:::

### The median {.smaller}

-   The `median()` function computes the "the halfway point of the data
    (50% of the data are above the median; 50% of the data are below"
    [@winter_statistics_2020: 58]

$$
\tilde{x}_{0.5} = 
\begin{cases}
x_{((n+1)/2)} & \text{if } n \text{ is odd.} \\
\frac{1}{2}(x_{n/2}+x_{(n/2+1)}) & \text{if } n \text{ is even.}
\end{cases} 
$$


```{r, echo = TRUE, output = TRUE}
# Using median()
median(cl.order$LEN_MC)

# or by hand:
sample_sorted <- sort(cl.order$LEN_MC) # sort values in ascending order

n <- length(cl.order$LEN_MC) # sample size is 403 (odd number!)

median <- sample_sorted[(n + 1) %/% 2] # compute median

```

**Visualisation**:

::: panel-tabset
#### Histogram

```{r, echo = TRUE, output = TRUE}
cl.length.hist +
  # Add mean
  geom_vline(aes(xintercept = mean(LEN_MC)), color = "steelblue", linewidth = 1) +
  # Add median
  geom_vline(aes(xintercept = median(LEN_MC)), color = "red", linewidth = 1) +
  theme_classic()
```

#### Density plot

```{r, echo = TRUE, output = TRUE}
cl.length.dens +
  # Add mean
  geom_vline(aes(xintercept = mean(LEN_MC)), color = "steelblue", linewidth = 1) +
  # Add median
  geom_vline(aes(xintercept = median(LEN_MC)), color = "red", linewidth = 1) +
  theme_classic()
```
:::

### Sample variance and standard deviation {.smaller}

-   In order to assess how well the mean represents the data, it is
    instructive to compute the **variance** `var()` and the **standard
    deviation** `sd()` for a sample.

-   The sample variance is defined as

$$s^2 = \frac{1}{n}\sum_{i=1}^n{(x_i - \bar{x})^2}. $$

```{r, echo = TRUE, output = TRUE}

# Using var()
var(cl.order$LEN_MC)

# or by hand:

sample_data <- cl.order$LEN_MC

# Calculate the sample standard deviation

var <- 1 / length(sample_data) * sum((sample_data - mean(sample_data))^2) # formula above

# Note that R's var() function applies an additional bias correction measure:

var_corrected <- 1 / (length(sample_data) - 1) * sum((sample_data - mean(sample_data))^2) # equivalent to var()

```

-   Correspondingly, the standard deviation of the mean is the square
    root of the variance [cf. @heumann_introduction_2022: 51-2]:

$$ s = \sqrt{\frac{1}{n}\sum_{i=1}^n{(x_i - \bar{x})^2}} $$

```{r, echo = TRUE, output = TRUE}
# Using sd()
sd(cl.order$LEN_MC)

# or by hand:

sample_data <- cl.order$LEN_MC

# Calculate the sample standard deviation

sd <- sqrt(1 / (length(sample_data) - 1)* sum((sample_data - mean(sample_data))^2))

```

**Application and visualisation**:

::: panel-tabset
#### Example 1

```{r, echo = TRUE, output = TRUE}
cl.length.hist +
  # Add verticle line for the mean
  geom_vline(aes(xintercept = mean(LEN_MC)), color = "steelblue", linewidth = 1) +
  # Add -1sd
  geom_vline(aes(xintercept = mean(LEN_MC) - sd(LEN_MC)), color = "orange", linewidth = 1) +
  # Add +1sd
  geom_vline(aes(xintercept = mean(LEN_MC) + sd(LEN_MC)), color = "orange", linewidth = 1) +
  theme_classic()
```

#### Example 2

```{r, echo = TRUE, output = TRUE}

# Create data frame with mean and sd for each clause ORDER

cl.order %>% 
  # Select variables of interest
  select(ORDER, LEN_MC) %>% 
  # Group results of following operations by ORDER
  group_by(ORDER) %>% 
    # Create grouped summary of mean and sd for each ORDER
    summarise(mean = mean(LEN_MC),
                sd = sd(LEN_MC)) -> cl_mean_sd; cl_mean_sd

# Plot results 

ggplot(cl_mean_sd, aes(x = ORDER, y = mean)) +
  # Barplot with a specific variable mapped onto y-axis
  geom_col() +
  # Add mean and standard deviation to the plot
  geom_errorbar(aes(x = ORDER,
                    ymin = mean-sd,
                    ymax = mean+sd), width = .2) +
  theme_classic() +
  labs(y = "Mean length of main clauses", x = "Clause order")
  
```
:::

### Quantiles

-   While `median()` divides the data into two equal sets (i.e., two 50%
    quantiles), the `quantile()` function makes it possible to partition
    the data further.

    ```{r, echo = TRUE}
    quantile(cl.order$LEN_MC)
    ```

-   `quantile(x, 0)` and `quantile(x, 1)` thus show the minimum and
    maximum values, respectively.

    ```{r, echo = TRUE}
    quantile(cl.order$LEN_MC, 0)
    quantile(cl.order$LEN_MC, 1)
    ```

### Quartiles and boxplots


-   Consider the distribution of clause length by clause order:

::: panel-tabset
#### Version 1

```{r, echo = TRUE, output = TRUE}
ggplot(cl.order, aes(x = ORDER, y = LEN_MC)) +
  geom_boxplot() +
  theme_classic()
```

#### Version 2

```{r, echo = TRUE, output = TRUE}
ggplot(cl.order, aes(x = ORDER, y = LEN_MC)) +
  geom_boxplot() +
  geom_jitter() + # add data points 
  theme_classic()
```
:::

-   Compare it to the corresponding rotated density plot:

```{r, echo = TRUE, output = TRUE}

ggplot(cl.order, aes(x = LEN_MC, fill = ORDER)) +
  geom_density(alpha = 0.5) +
  coord_flip() +
  theme_classic()

```

## Theoretical distributions

### The normal distribution

A great number of numerical variables in the world follow the well-known
**normal** (or Gaussian) **distribution**, which includes test scores,
weight and height, among many others.

If a random variable $X$ is normally distributed, it is determined by
the parameters $\mu$ (the mean) and $\sigma$ (the standard deviation).
Formally, we can summarise this using the notation

$$ X \sim N(\mu, \sigma^2).$$ The **probability density function (PDF)**
of the normal distribution has a characteristic bell-shape. The density
values on the $y$-axis indicate the likelihood of encountering a
specific value of $X$ [cf. @winter_statistics_2020: 56;
@heumann_introduction_2022: 173-177].

```{r, echo = FALSE, output = TRUE, warning = FALSE, message = FALSE}

# Step 1: Generate data from a normal distribution
set.seed(123) # for reproducibility
data <- rnorm(1000, mean = 0, sd = 1)

# Step 2: Calculate mean and standard deviation
mean_val <- mean(data)
sd_val <- sd(data)

# Step 3: Create a data frame for plotting
x_values <- seq(mean_val - 3*sd_val, mean_val + 3*sd_val, length.out = 1000)
y_values <- dnorm(x_values, mean = mean_val, sd = sd_val)
plot_data <- data.frame(x = x_values, y = y_values)

# Step 4: Plot the normal distribution curve
#ggplot(plot_data, aes(x = x, y = y)) +
 # geom_line() +
  #labs(title = "Normal Distribution",
   #    x = "X",
    #   y = "Density")

# Step 5: Add markers at mean, mean +/- 1 SD, mean +/- 2 SD, and mean +/- 3 SD
ggplot(plot_data, aes(x = x, y = y)) +
  geom_line() +
  geom_vline(xintercept = c(mean_val - 3*sd_val, mean_val - 2*sd_val, mean_val - sd_val, mean_val, mean_val + sd_val, mean_val + 2*sd_val, mean_val + 3*sd_val), color = "darkgreen", linetype = "dashed") +
  geom_text(aes(x = mean_val - 3*sd_val, label = "-3 SD"), y = 0.1, vjust = -0.5) +
  geom_text(aes(x = mean_val - 2*sd_val, label = "-2 SD"), y = 0.1, vjust = -0.5) +
  geom_text(aes(x = mean_val - sd_val, label = "-1 SD"), y = 0.1, vjust = -0.5) +
  geom_text(aes(x = mean_val, label = "Mean"), y = 0.1, vjust = -0.5) +
  geom_text(aes(x = mean_val + sd_val, label = "+1 SD"), y = 0.1, vjust = -0.5) +
  geom_text(aes(x = mean_val + 2*sd_val, label = "+2 SD"), y = 0.1, vjust = -0.5) +
  geom_text(aes(x = mean_val + 3*sd_val, label = "+3 SD"), y = 0.1, vjust = -0.5) +
  labs(title = "Normal Distribution",
       x = "X",
       y = "Density") +
  theme_minimal()

```

### Bernoulli distribution

The **Bernoulli distribution** is a discrete probability distribution
for random variables which have only two possible outcomes: "positive"
(often coded as 1) and "negative" (often coded as 0). Examples of such
variables include coin tosses (heads/tails), binary response questions
(yes/no), and defect status (defective/non-defective).

If a random variable $X$ follows a Bernoulli distribution, it is
determined by the parameter $p$, which is the probability of the
positive case:

$$ X \sim Bernoulli(p).$$ The **probability mass function (PMF)** of the
Bernoulli distribution is given by: $$
P(X = x) = 
\begin{cases} 
p & \text{if } x = 1 \\
1 - p & \text{if } x = 0 
\end{cases}
$$

where $0 \leq p \leq 1$. This function shows the probability of $X$
taking on the value of 1 or 0 [cf. @heumann_introduction_2022: 162-163].

```{r, echo = FALSE, output = TRUE}

#Step 1: Define the probability of success
p <- 0.3  # You can change this value to see different scenarios

# Step 2: Create a data frame for the Bernoulli distribution
bernoulli_data <- data.frame(
  outcome = c(0, 1),
  probability = c(1 - p, p)
)

# Step 3: Plot the Bernoulli distribution
ggplot(bernoulli_data, aes(x = factor(outcome), y = probability)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  geom_text(aes(label = round(probability, 2)), vjust = -0.5) +
  labs(title = "Bernoulli Distribution",
       x = "Outcome",
       y = "Probability") +
  theme_minimal()

```

::: callout-note
### Extensions

A Bernoulli experiment presupposes a single trial (e.g., tossing a coin
once). If we are interested in the distribution of a binary discrete
variable over $n$ Bernoulli trials, we can describe it in terms of the
**binomial distribution** [@heumann_introduction_2022: 163-166].

Categorical variables with more than 2 outcomes and $n$ Bernoulli trials
can be modelled using the **multinomial distribution**
[@heumann_introduction_2022: 167-169].
:::
