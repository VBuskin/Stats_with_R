---
title: "Categorical data"
author: Vladimir Buskin
format:
  html:
    self-contained: false
    theme: default
    toc: true
    number-sections: true
    slide-number: true
    incremental: false
    slide-level: 3
    scrollable: true
editor: visual
bibliography: R.bib
---

## Preparation

Please download the file "Paquot_Larsson_2020_data.xlsx"
[@paquotDescriptiveStatisticsVisualization2020][^categorical_data-1] and
store it in the same folder as your currently active R-script.

[^categorical_data-1]: The original supplementary materials can be
    downloaded from the publisher's
    [website](https://link.springer.com/chapter/10.1007/978-3-030-46216-1_17)
    \[Last accessed April 28, 2024\].

```{r, echo = TRUE, output = TRUE}
# Libraries
library("readxl")
library("tidyverse")

# Load data from working directory
cl.order <- read_xlsx("Paquot_Larsson_2020_data.xlsx")

```

It contains the **dependent variable**

-   `ORDER`: Does the subordinate clause come before or after the main
    clause? ('sc-mc' vs. 'mc-sc')

... and the **independent variables**:

-   `SUBORDTYPE`: Is the subordinate clause temporal or causal? ('temp'
    vs. 'caus')

-   `MORETHAN2CL`: Are there most clauses in the sentence than just one
    subordinate clause and one main clause? ('yes' vs. 'no')

-   `LEN_MC`: How many words does the main clause contain? (ratio-scaled
    continuous variable)

-   `LEN_SC`: How many words does the subordinate clause contain?
    (ratio-scaled continuous variable)

-   `LENGTH_DIFF`: What is the length difference in words between the
    main clause and subordinate clause? (ratio-scaled continuous
    variables)

## Descriptive measures

The easiest way to get a general overview of the full data set is to
apply the `str()` function to the respective data frame.

```{r}
str(cl.order)
```

This shows us that the data frame has 8 columns, as the `$` operators
indicate (`$ Case`, `$ ORDER`, ...). The column names are followed by

-   the data type (`num` for numeric and `chr` for character strings)

-   the number of values (`` `[1:403]` ``) and

-   the first few observations.

Another intuitive way to display the structure of a data matrix is to
simply show the first few rows:

```{r}
head(cl.order)
```

### Frequency tables

#### One variable

Each categorical variable is made up of two or more categories. A simple
descriptive measure is the frequency of each category. The table below
indicates how often each clause order occurs in the data.

```{r}
order_freq1 <- table(cl.order$ORDER) 

print(order_freq1)
```

The notation `cl.order$ORDER` subsets the `cl.order` according to the
column `ORDER` (see [data frames](Data_frames.qmd)).

Alternatively, you could use `xtabs()` to achieve the same result --
perhaps with a slightly more intuitive syntax.

```{r}
order_freq2 <- xtabs(~ ORDER, cl.order)

print(order_freq2)
```

#### Two variables

If we are interested in the relationship between multiple categorical
variables, we can cross-tabulate the frequencies of their categories.
For example, what is the distribution of clause order depending on the
type of subordinate clause?

```{r}
order_counts1 <- table(cl.order$ORDER, cl.order$SUBORDTYPE)

print(order_counts1)
```

Here is the `xtabs()` alternative:

```{r}
order_counts2 <- xtabs(~ ORDER + SUBORDTYPE, cl.order)

print(order_counts2)
```

::: {.callout-note collapse="false" title="How do I obtain percentages?"}
There are two ways to convert the raw frequency counts to percentage
tables:

1.  Manually divide all cells by the total number of observations (which
    correspond to the sum of all cells) and multiply the result by 100.

```{r}
pct1 <- order_counts1/sum(order_counts1) * 100
```

2.  Use the `prop.table()` function and multiply the result by 100.

```{r}
pct2 <- prop.table(order_counts1) * 100
```
:::

## Visualising categorical variables

This section demonstrates both the in-built plotting functions of R
('Base R') as well as the more modern versions provided by the
`tidyverse` package.

### One variable

::: panel-tabset
### Base R

-   Base R barplot with `barplot()`; requires the counts as computed by
    `tables()` or `xtabs()`

```{r}
barplot(order_freq1) # Supply the counts

```

### ggplot2

-   Barplot with `geom_bar()` using the raw input data

```{r, echo = TRUE, output = TRUE}
library(tidyverse)

ggplot(cl.order, aes(x = ORDER)) +
  geom_bar()

```
:::

### Two variables

-   Barplots with the `fill` argument

::: panel-tabset
### Base R

```{r}
barplot(order_counts2, 
        beside = TRUE,  # Make bars side-by-side
        legend = TRUE)  # Add a legend
```

### Base R (fully customised)

```{r}
barplot(order_counts2, 
        beside = TRUE,  # Make bars dodged (i.e., side by side)
        main = "Distribution of ORDER by SUBORDTYPE (Base R)", 
        xlab = "ORDER", 
        ylab = "Frequency", 
        col = c("lightblue", "lightgreen"), # Customize colors
        legend = TRUE,  # Add a legend
        args.legend = list(title = "SUBORDTYPE", x = "topright"))
```

### ggplot2

```{r, echo = TRUE, output = TRUE}
library(tidyverse)

ggplot(cl.order, aes(x = ORDER, fill = SUBORDTYPE)) +
  geom_bar(position = "dodge")
```

### ggplot2 (fully customised)

```{r, echo = TRUE, output = TRUE}
library(tidyverse)

ggplot(cl.order, aes(x = ORDER, fill = SUBORDTYPE)) +
  geom_bar(position = "dodge") +
  labs(
    title = "Clause order by subordinate clause type",
    x = "Clause order",
    y = "Frequency",
    fill = "Type of subordinate clause"
  ) +
  theme_bw()
```
:::

::: {.callout-note collapse="false" title="How do I plot percentages?"}
In Base R, very much the same way as with the raw counts:

```{r}
barplot(pct1, 
        beside = TRUE,  # Make bars side-by-side
        legend = TRUE)  # Add a legend
```

In ggplot2, a few tweaks are necessary. In general, ggplot2 only works
with data frames and not with table objects, so we'd have to convert it
to one first:

```{r}
pct1_df <- as.data.frame(pct1)

print(pct1_df)
```

Now we can plot the percentages with `geom_col()`. This geom (=
'geometric object') allows us to manually specify what should be mapped
onto the y-axis:

```{r}
library(tidyverse)

ggplot(pct1_df, aes(x = Var1, y = Freq, fill = Var2)) +
  geom_col(position = "dodge")

```
:::

## Exporting tables to MS Word

Publication-ready tables can be generated with the help of the
`flextable` package. The full guide can be found
[here](https://ardata-fr.github.io/flextable-book/crosstabs.html#using-tables).

```{r, output = FALSE}
library(flextable)
output_1 <- as_flextable(pct1)
print(output_1)
```

![](crosstable_plot1.png)

The `rempsyc` also provides a simple way of creating beautiful,
export-ready tables. You can find the documentation
[here](https://rempsyc.remi-theriault.com/articles/table).

```{r, output = FALSE}

library(rempsyc)

# Format table
output2 <- nice_table(pct1_df)

print(output2)
```

![](crosstable_plot2.png)

```{r, eval = FALSE}
# Export to Microsoft Word
print(output2, preview = "docx")

```
