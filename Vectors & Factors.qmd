---
title: "Data Structures in R: A cheatsheet"
author: Vladimir Buskin
format:
  html:
    self-contained: true
    theme: default
    toc: true
    number-sections: true
    slide-number: true
    incremental: false
    slide-level: 3
    scrollable: true
    
editor: visual
---

## Suggested reading

-   Gries (2013: Chapter 2)

-   James et al. (2021: Chapter 2.3)

-   Winter (2019: Chapter 1)

## Functions and arguments {.smaller}

::: panel-tabset
### Description

::: {.fragment fragment-index="1"}
-   To call or invoke a built-in function in R you write the name of the
    function and then enter its argument values enclosed in parentheses
    and separated by commas.
:::

::: {.fragment fragment-index="2"}
-   **Pattern**:
    $\text{function}(\text{argument}_1, \text{argument}_2, ..., \text{argument}_n)$
    which translates to 'apply the function to argument$_1$,
    argument$_2$, ..., argument$_n$'.
:::

::: {.fragment fragment-index="3"}
-   **Example**: The `seq()` function produces arithmetic sequences:

```{r, echo = TRUE}
seq(from = 1, to = 9, by = 2)
```
:::

::: {.fragment fragment-index="4"}
-   Every function has a default order for the arguments. If you provide
    arguments in this order, then they do not need to be named.

```{r, echo = TRUE}
seq(1, 9, 2)
```
:::

### Some useful functions

::: {.fragment fragment-index="1"}
-   `c()` to combine numbers or character strings into a vector

```{r, echo = TRUE}
# Concatenate the numbers 1, 2 and 3 into vector "a"
a <- c(1, 2, 3)

# Print "a"
a
```
:::

::: {.fragment fragment-index="2"}
-   `class()` and `str()` to inspect the structure of objects

```{r, echo = TRUE}
class(a)
```

```{r, echo = TRUE}
str(a)
```
:::

::: {.fragment fragment-index="3"}
-   `rm()` to remove objects from the working environment

```{r, echo = TRUE}
rm(a)
```
:::
:::

## Variables {.smaller}

::: {.fragment fragment-index="1"}
-   Variables are similar to **folders**: they can be filled with
    information, inspected, and changed.
:::

::: {.fragment fragment-index="2"}
-   To assign a value to a variable we use the **assignment command**
    `<-`.

```{r, echo = TRUE}

# Assign the value 100 to the variable x
x <- 100

# Print the content of x
print(x)
```

```{r, echo = TRUE}
# or simply:
x
```
:::

::: {.fragment fragment-index="3"}
-   The variables currently stored are displayed in the **Environment**
    tab. You can also list them in the console with `ls()`.
:::

## Vectors {.smaller}

::: panel-tabset
### Generating vectors

::: {.fragment fragment-index="1"}
-   In R, vectors are **indexed lists of variables**. They can be
    generated with the functions `c()`, `seq()` and `rep()`.

```{r, echo = TRUE}
# Define a character vector "vehicles"
vehicles <- c("car", "truck", "bus")

# Print the content of vehicles
vehicles
```
:::

::: {.fragment fragment-index="3"}
-   We can access the `i`-th element of a vector `x` using the notation
    `x[i]`.

```{r, echo = TRUE}
# Access the first element of vehicles
vehicles[1]
```
:::

### Editing vectors

::: {.fragment fragment-index="4"}
-   View content of one or several indexed positions

```{r, echo = TRUE, output = TRUE}
# View the first two elements
vehicles[1:2]

```
:::

::: {.fragment fragment-index="5"}
-   Where in the vector does a specific property apply?

```{r, echo = TRUE}
vehicles == "bus"
```
:::

::: {.fragment fragment-index="6"}
-   Do multiple properties apply?

```{r, echo = TRUE}
c("truck", "bus") %in% vehicles
```
:::

::: {.fragment fragment-index="7"}
-   What positions do certain elements occupy in a vector?

```{r, echo = TRUE}
match(c("truck", "bus"), vehicles)
```
:::
:::

## Factors {.smaller}

::: panel-tabset
### Generating factors

::: {.fragment fragment-index="1"}
-   First, generate a vector such as

```{r, echo = TRUE}
articles <- c("a", "the", "a", "a", "a", "the", "the")
```
:::

::: {.fragment fragment-index="2"}
-   Convert the vector to a factor using the `factor()` function:

```{r, echo = TRUE}
articles <-  factor(articles)
```
:::

::: {.fragment fragment-index="3"}
-   Inspect the contents of the factor

```{r, echo = TRUE}
articles
```
:::

::: {.fragment fragment-index="4"}
-   Check the levels of "articles"

```{r, echo = TRUE}
levels(articles)
```
:::

### Editing factors

::: {.fragment fragment-index="5"}
-   Change the reference level of a factor:

```{r, echo = TRUE}

# Prior to changing the reference level
levels(articles)

# Changing the reference level
articles <- relevel(articles, ref = "the")

levels(articles)
```
:::

::: {.fragment fragment-index="6"}
-   Change a factor level:

```{r, echo = TRUE}
# Change level "the" to "def_art" (definite article)
levels(articles)[1] <- "def_art"

# Change level "a" to "indef_art" (indefinite article)
levels(articles)[2] <- "indef_art"
```

```{r, echo = TRUE}
# Print "articles"
print(articles) # the original levels "the" and "a" have been replaced
```
:::

::: {.fragment fragment-index="7"}
-   Change factor back to a character/numeric vector using
    `as.character()`or `as.numeric()`:

```{r, echo = TRUE}
articles <- as.character(articles)

str(articles)
```
:::
:::

## Data frames

### Data frames in Base R {.smaller}

::: panel-tabset
#### Generating data frames {.smaller}

::: {.fragment fragment-index="1"}
-   Data frames are comparable to spreadsheets. They can be built by
    combining multiple vectors and applying the `data.frame()` function
    to them.

```{r, echo = TRUE}
# Define the columns
participant <-  c("louis", "paula", "vincenzo")
score <- c(67, 85, 32)

# Combine the columns into a data frame
mydf <- data.frame(participant, score)
mydf

```
:::

::: {.fragment fragment-index="2"}
-   You can check the structure of the data frame with `str()`

```{r, echo = TRUE}
str(mydf)
```
:::

#### Editing data frames {.smaller}

::: {.fragment fragment-index="3"}
-   The individual columns of a data frame can be accessed using the `$`
    symbol:

```{r, echo = TRUE}
mydf$participant

```
:::

::: {.fragment fragment-index="4"}
-   Just like with vectors, it is possible to access specific elements
    of a data frame.

```{r, echo = TRUE, output = FALSE}
# First row
mydf[1,]

# Second column
mydf[,2]

# First two rows
mydf[1:2,]

# First column, second entry
mydf[,1][2]
```
:::

::: {.fragment fragment-index="5"}
-   Extract those cells for which a certain property applies:

```{r, echo = TRUE, output = FALSE}
# Extract the row for Vincenzo
mydf[mydf$participant == 'vincenzo',]

# Further subset this data frame to obtain the score only
mydf[mydf$participant == 'vincenzo',]$score

```
:::
:::

### Data frames in the `tidyverse`

-   Installing and loading the tidyverse

```{r, echo = TRUE}
#install.packages("tidyverse")
library("tidyverse")
```

-   Install the dataset

```{r, echo = TRUE}
#install.packages("nycflights13")
library(nycflights13)
flights
```

#### Rows

##### `filter()`

-   Show flights where the departure was delayed by more than 120
    minutes

```{r, echo = TRUE}
flights %>% # specify data frame
  filter(dep_delay > 120) # apply filter
```

-   Flights that departed on January 1

```{r, echo = TRUE}
flights %>% 
  filter(month == 1 & day == 1)
```

##### `arrange()`

-   Specify the order of the columns

```{r, echo = TRUE}
flights %>% 
  arrange(year, month, day, dep_time)
```

-   Order the values of the columns in descending order

```{r, echo = TRUE}
flights %>%  
  arrange(desc(dep_delay))
```

#### Columns

##### `mutate()`

-   Add new columns to the data frame

```{r, echo = TRUE}
flights %>%  
  mutate(
    gain = dep_delay - arr_delay, # add gain column
    speed = distance / air_time * 60, # add speed column
    .before = 1 # add new columns to the left of the df
  )
```

##### `select()`

##### `rename()`

##### `relocate()`

#### The pipeline {.smaller}

-   Depending on your goal, it may be necessary to combine the various
    mode of data manipulation

```{r, echo = TRUE}
flights %>% # data frame
  filter(dest == "IAH") |>  # only flights to IAH
  mutate(speed = distance / air_time * 60) |>  # create column with speed
  select(year:day, dep_time, carrier, flight, speed) |>  # choose variables
  arrange(desc(speed)) # sort values in descending order
```

#### Groups

##### `group_by()` and `summarize()`

-   State that all further operations should be organised by "month"

```{r, echo = TRUE}
flights %>%  
  group_by(month)
```

-   Compute the average delay per month

```{r, echo = TRUE}
flights %>%  
  group_by(month) %>% 
  summarize(
    delay = mean(dep_delay, na.rm = TRUE), # second argument removes missing values
    n = n() # shows number of rows in this group
  )
```
