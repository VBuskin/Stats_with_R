{
  "hash": "df818311af34978e53e3c30630183ce5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data frames\"\nauthor: Vladimir Buskin\nformat:\n  html:\n    self-contained: true\n    theme: default\n    toc: true\n    number-sections: true\n    slide-number: true\n    incremental: false\n    slide-level: 3\n    scrollable: true\n    \neditor: visual\n---\n\n\n## Recommended reading\n\n> @winter_statistics_2020: Chapter 1.10-1.16\n\nSuggested video tutorial:\n\n> [Using the Data Frame in\n> R](https://www.youtube.com/watch?v=9f2g7RN5N0I) (DataCamp, 5min)\n>\n> [Learn How to Subset, Extend & Sort Data Frames in\n> R](https://www.youtube.com/watch?v=Nh6tSD4i4qs) (DataCamp, 7min)\n\n## Word frequencies II\n\nRecall our corpus-linguistic data from the previous unit:\n\n| Lemma | Frequency |\n|-------|-----------|\n| start | 418       |\n| enjoy | 139       |\n| begin | 337       |\n| help  | 281       |\n\nWe thought of the columns as one-dimensional, indexed lists of elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlemma <- c(\"start\", \"enjoy\", \"begin\", \"help\")\n\nfrequency <- c(418, 139, 337, 281)\n```\n:::\n\n\nActually, R allows to combine these two vectors into something that\nresembles a real spreadsheet. To this end, we need to apply the\n`data.frame()` to two vectors of our choice.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data.frame(lemma, frequency)\n\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  lemma frequency\n1 start       418\n2 enjoy       139\n3 begin       337\n4  help       281\n```\n\n\n:::\n:::\n\n\n## Essential R concepts {#sec-df}\n\nThe variable `data` is no longer a vector, but a **data frame** (often\nabbreviated as 'df'). Once again, each element carries its own label and\ncan, therefore, be accessed or manipulated.\n\nSince we now have two dimensions, the **subsetting** notation in square\nbrackets `[ ]` has to reflect that. This is the general pattern:\n\n$$ df[row, column] $$Following this logic, we can get the element in the\nfirst row of the first column like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata[1,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"start\"\n```\n\n\n:::\n:::\n\n\nIf we, however, need the entire first row, we simply omit the column\npart. The comma `,` needs to stay there:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  lemma frequency\n1 start       418\n```\n\n\n:::\n:::\n\n\nSubsetting by columns is interesting. We can either use the explicit\nnotation with square brackets or the **column operator** `$`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata[,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"start\" \"enjoy\" \"begin\" \"help\" \n```\n\n\n:::\n\n```{.r .cell-code}\ndata$lemma\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"start\" \"enjoy\" \"begin\" \"help\" \n```\n\n\n:::\n:::\n\n\n## Handling data frames `tidyverse`-style\n\nThe `tidyverse`-ecosystem is a collection of packages specifically\ndesigned for handling typical data science tasks as comfortably and\nelegantly as possible, supplying countless helper functions for data\nmanipulation, transformation and visualisation.\n\nIt offers some appealing alternatives to the Base R subsetting\nfunctions. Let's generate a tidyverse-style data frame, the **tibble**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\ndata2 <- tibble(\n  lemma = c(\"start\", \"enjoy\", \"begin\", \"help\"),\n  frequency = c(418, 139, 337, 281)\n)\n\nprint(data2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  lemma frequency\n  <chr>     <dbl>\n1 start       418\n2 enjoy       139\n3 begin       337\n4 help        281\n```\n\n\n:::\n:::\n\n\nWe can single out certain columns by using `select()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(data2, lemma)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 1\n  lemma\n  <chr>\n1 start\n2 enjoy\n3 begin\n4 help \n```\n\n\n:::\n:::\n\n\nIt is very easy to filter the data frame according to certain criteria:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(data2, lemma == \"start\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  lemma frequency\n  <chr>     <dbl>\n1 start       418\n```\n\n\n:::\n\n```{.r .cell-code}\nfilter(data2, frequency > 150)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  lemma frequency\n  <chr>     <dbl>\n1 start       418\n2 begin       337\n3 help        281\n```\n\n\n:::\n:::\n\n\nA extensive guide to the main tidyverse functions is provided in Chapter\n3 of the free eBook [R For Data Science (2nd\nedition)](https://r4ds.hadley.nz).\n\n## Exercises\n\n1.  Recreate the barplot from the previous unit by subsetting the `data`\n    variable accordingly.\n\n2.  \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}