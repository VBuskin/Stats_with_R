{
  "hash": "84759332c2cd93e9d0661388592760f4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data frames\"\nauthor: Vladimir Buskin\nformat:\n  html:\n    self-contained: true\n    theme: default\n    toc: true\n    number-sections: true\n    slide-number: true\n    incremental: false\n    slide-level: 3\n    scrollable: true\n    \neditor: visual\n---\n\n\n## Preparation\n\n::: callout-tip\n## Script\n\nYou can find the full R script associated with this unit ...\n:::\n\n## Recommended reading\n\n> @winter_statistics_2020: Chapter 1.10-1.16\n\nSuggested video tutorial:\n\n> [Using the Data Frame in\n> R](https://www.youtube.com/watch?v=9f2g7RN5N0I) (DataCamp, 5min)\n>\n> [Learn How to Subset, Extend & Sort Data Frames in\n> R](https://www.youtube.com/watch?v=Nh6tSD4i4qs) (DataCamp, 7min)\n\n## Word frequencies II\n\nRecall our corpus-linguistic data from the previous unit:\n\n| Lemma | Frequency |\n|-------|-----------|\n| start | 418       |\n| enjoy | 139       |\n| begin | 337       |\n| help  | 281       |\n\nWe thought of the columns as one-dimensional, indexed lists of elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlemma <- c(\"start\", \"enjoy\", \"begin\", \"help\")\n\nfrequency <- c(418, 139, 337, 281)\n```\n:::\n\n\nActually, R allows us to combine these two vectors into something that\nresembles a real spreadsheet. To this end, we apply the `data.frame()`\nfunction to two vectors of our choice.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data.frame(lemma, frequency)\n\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  lemma frequency\n1 start       418\n2 enjoy       139\n3 begin       337\n4  help       281\n```\n\n\n:::\n:::\n\n\n### Essential R concepts {#sec-df}\n\nThe variable `data` is no longer a vector, but a **data frame** (often\nabbreviated as 'df'). Once again, each element carries its own label and\ncan, therefore, be accessed or manipulated.\n\nSince we now have two dimensions, the **subsetting** notation in square\nbrackets `[ ]` has to reflect that. This is the general pattern:\n\n$$ df[row, column]\n$$ {#eq-df}\n\nSay, we're looking for the element at the intersection of the first row\nand first column. Applying the pattern above, we can access it like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata[1,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"start\"\n```\n\n\n:::\n:::\n\n\nBut what if we need the entire first row? We simply omit the column\npart. Note, however, that the comma `,` needs to remain:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  lemma frequency\n1 start       418\n```\n\n\n:::\n:::\n\n\nSubsetting by columns is interesting. We can either use the square\nbracket notation `[ ]` or the **column operator** `$`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata[,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"start\" \"enjoy\" \"begin\" \"help\" \n```\n\n\n:::\n\n```{.r .cell-code}\ndata$lemma\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"start\" \"enjoy\" \"begin\" \"help\" \n```\n\n\n:::\n:::\n\n\n### Filtering\n\nNot all the information contained in a data frame is always relevant for\nour research. In those cases, it's important to subset the rows and\ncolumns according to certain criteria.\n\nAssume we only need those observations where the lemma frequencies are\ngreater than 300. We can obtain those by specifying\n\n1.  the data frame,\n2.  the column of interest and\n3.  the condition to apply.\n\nYou can read the code below as\n\n> Take the data frame `data` and subset it according to the column\n> `data$frequency`. Show me those rows where the values of\n> `data$frequency` are greater than 300.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata[data$frequency > 300, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  lemma frequency\n1 start       418\n3 begin       337\n```\n\n\n:::\n:::\n\n\nWhat if we wanted to filter by `lemma` instead? Let's say we're looking\nfor frequency data on the verbs *start* and *help*.\n\nThis will give us the row associated with *start*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata[data$lemma == \"start\", ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  lemma frequency\n1 start       418\n```\n\n\n:::\n:::\n\n\nCombining multiple statements requires a **logical operator**. Here\nwe're using `|` , which corresponds to a logical 'or' (disjunction).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata[data$lemma == \"start\" | data$lemma == \"help\", ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  lemma frequency\n1 start       418\n4  help       281\n```\n\n\n:::\n:::\n\n\n::: callout-caution\n### Why do we need to use \"or\" (\\|) and not \"and\" (&)?\n\nThe idea of combining statements somewhat naturally suggests a\nconjunction, which could be achieved via `&`. How come R doesn't return\nanything if we do it that way?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata[data$lemma == \"start\" & data$lemma == \"help\", ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] lemma     frequency\n<0 rows> (or 0-length row.names)\n```\n\n\n:::\n:::\n\n:::\n\n### I don't like the way this looks – is there another way to filter in R?\n\nYes, absolutely. The subsections below demonstrate a few popular\nalternatives. In the end, the exact way you filter doesn't really\nmatter, so long as you (as well as the people who have to work with your\nscript) can understand what you're trying to achieve. Always consider\nadding comments to your filtering operations!\n\n#### `subset()`\n\nAlmost every subsetting operation we perform with square brackets can\nalso be performed using the `subset()` function. Here are some\nexpressions that are synonymous to the ones above:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset(data, frequency > 300)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  lemma frequency\n1 start       418\n3 begin       337\n```\n\n\n:::\n\n```{.r .cell-code}\nsubset(data, lemma == \"start\" | lemma == \"help\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  lemma frequency\n1 start       418\n4  help       281\n```\n\n\n:::\n:::\n\n\n#### `tidyverse`\n\nThe `tidyverse`-ecosystem is a collection of packages specifically\ndesigned for handling typical data science tasks as comfortably and\nelegantly as possible, supplying countless helper functions for data\nmanipulation, transformation and visualisation. Installation\ninstructions are provided in @sec-libraries.\n\nIt offers some appealing alternatives to the Base R subsetting\nfunctions. Let's generate a tidyverse-style data frame, the **tibble**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\ndata2 <- tibble(\n  lemma = c(\"start\", \"enjoy\", \"begin\", \"help\"),\n  frequency = c(418, 139, 337, 281)\n)\n\nprint(data2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  lemma frequency\n  <chr>     <dbl>\n1 start       418\n2 enjoy       139\n3 begin       337\n4 help        281\n```\n\n\n:::\n:::\n\n\nWe can single out certain columns by using `select()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(data2, lemma)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 1\n  lemma\n  <chr>\n1 start\n2 enjoy\n3 begin\n4 help \n```\n\n\n:::\n:::\n\n\nIt is very easy to filter the data frame according to certain criteria:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(data2, frequency > 300)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  lemma frequency\n  <chr>     <dbl>\n1 start       418\n2 begin       337\n```\n\n\n:::\n\n```{.r .cell-code}\nfilter(data2, lemma == \"start\" | lemma == \"help\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  lemma frequency\n  <chr>     <dbl>\n1 start       418\n2 help        281\n```\n\n\n:::\n:::\n\n\nA extensive guide to the main tidyverse functions is provided in Chapter\n3 of the free eBook [R For Data Science (2nd\nedition)](https://r4ds.hadley.nz).\n\n## Exercises\n\n::: callout-tip\n## Solutions\n\nYou can find the solutions to the exercises\n[here](https://osf.io/967hj).\n:::\n\n::: {#exr-df-1}\nRecreate the barplot from the previous unit by subsetting the `data`\nvariable accordingly.\n:::\n\n::: {#exr-df-2}\nPrint the following elements by subsetting the data frame `data`\naccordingly.\n\n-   337\n\n-   *begin*\n\n-   *enjoy*\n\n-   *enjoy* 139\n\n-   the entire frequency column\n\n:::\n\n::: {#exr-df-3}\nExtension of @exr-v-3. Verify that the following verbs are represented\nin the lemma column: *enjoy*, *hit*, *find*, *begin*. If they are in the\ndata frame, print their frequency information.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}