{
  "hash": "1f1af33a48b0d207396d2e81a6d227e2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Vectors\"\nauthor: Vladimir Buskin\nformat:\n  html:\n    self-contained: false\n    theme: default\n    toc: true\n    number-sections: true\n    slide-number: true\n    incremental: false\n    slide-level: 3\n    scrollable: true\n    \neditor: visual\n---\n\n\n\n## Recommended reading\n\n> @winter_statistics_2020: Chapter 1.1â€“1.9\n\n## Word frequencies I\n\nYou are given the following token counts of English verb lemmas in the\nInternational Corpus of English:\n\n| Lemma | Frequency |\n|-------|-----------|\n| start | 418       |\n| enjoy | 139       |\n| begin | 337       |\n| help  | 281       |\n\nIt is always a good idea to visualise frequency data in some way. Quite\nconveniently, R happens to provide us with an abundance of plotting\nfunctions. To create a two-dimensional plot, we need to generate two\nobjects in R: one for the individual lemmas and one for the frequency\ncounts.\n\nLet's combine the lemmas *start, enjoy, begin* and *help* using R's\n`c()` function and store them in an object `lemma`. Enter the following\nline into a new R script and click on **Run** (or simply press\nCtrl+Enter/Cmd+Enter).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlemma <- c(\"start\", \"enjoy\", \"begin\", \"help\")\n```\n:::\n\n\n\nWe can now do the same for the frequency information:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrequency <- c(418, 139, 337, 281)\n```\n:::\n\n\n\n::: {.callout-tip title=\"When do I use quotation marks?\" collapse=\"true\"}\nLetters and numbers represent two distinct data types in R. Anything\nthat should be understood as a simple sequence of letters or words must\nbe enclosed by quotation marks `\"...\"`. An expression such as `start`\nwill then be evaluated as a **string**.\n\n**Numbers** (or **integers**), by contrast, appear without quotation\nmarks.\n:::\n\nOur linguistic data is now stored in two **variables** `lemma` and\n`frequency`, which you can conceptualise as virtual container-like\nobjects. You will also notice that they are now showing in the\n**Environment** tab in the top right corner of RStudio.\n\nThe combination of categorical labels and numeric information renders\nour data ideally suited for a barplot. R's most basic barplot function\n(which is, unsurprisingly, called `barplot()`) needs at the very least\n...\n\n-   a `height` argument, i.e., our y-axis values and\n\n-   a `names.arg` argument, i.e., our x-axis labels.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(frequency, names.arg = lemma, col = \"skyblue\")\n```\n\n::: {.cell-output-display}\n![](Vectors_Factors_files/figure-pdf/unnamed-chunk-3-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nAfter some tinkering, our plot looks more presentable:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(frequency, names.arg = lemma, \n        main = \"Frequency of Lemmas\", # title\n        xlab = \"Lemmas\",  # label for x-axis\n        ylab = \"Frequency\", # label for y-axis\n        col = \"steelblue\") # color\n```\n\n::: {.cell-output-display}\n![](Vectors_Factors_files/figure-pdf/unnamed-chunk-4-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n::: {.callout-tip title=\"What does '#' mean? On comments in R\" collapse=\"true\"}\nIn R, everything followed by the hashtag `#` will be interpreted as a\ncomment and won't be evaluated by the R compiler. While comments don't\naffect the output of our code in the slightest, they are **crucial** to\nany kind of programming project.\n\nAdding prose annotations to your code will make not only it easier to\nunderstand for others but also for your future self. Poor documentation\nis a common, yet unnecessary source of frustration for all parties\ninvolved ...\n\n![](comments_meme.png){fig-align=\"center\" width=\"60%\"}\n:::\n\nIn RStudio, you now have the option to save the plot to your computer.\nOnce the figure has appeared in your \"Plots\" panel, you can click on\n\"Export\" in the menu bar below and proceed to choose the desired output\nformat and file directory.\n\n## Some technical details\n\nThe example above demonstrates one of the most important data structures\nin R: **Vectors**. They form the cornerstone of various more complex\nobjects such as data frames, and are essential to handling large data\nsets (e.g., corpora). And yet, vectors are very simple in that they\nmerely constitute one-dimensional sequences of characters or numbers --\nno more, no less.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(lemma)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"start\" \"enjoy\" \"begin\" \"help\" \n```\n\n\n:::\n\n```{.r .cell-code}\nprint(frequency)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 418 139 337 281\n```\n\n\n:::\n:::\n\n\n\nThe individual elements in these two vectors are not randomly jumbling\naround in virtual space, but are in fact following a clear order. Each\nelement has an \"ID\" (or **index**), by which we can access it. For\nexample, if we want to print the first lemma in our `lemma` variable, we\ncan use this notation:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlemma[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"start\"\n```\n\n\n:::\n:::\n\n\n\nSimilarly, we can subset `frequency` according to, for example, its\nthird element:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrequency[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 337\n```\n\n\n:::\n:::\n\n\n\nWe can also obtain entire ranges of elements, such as everything from\nthe second to the fourth one:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrequency[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 139 337 281\n```\n\n\n:::\n:::\n\n\n\n## Exercises\n\n1.  Create a vector that lists the third person personal pronouns of\n    English (subject and object forms). Store them in a variable `pp3`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution:\"}\npp3 <- c(\"he\", \"she\", \"it\", \"him\", \"her\", \"they\", \"them\")\n```\n:::\n\n\n\n2.  Now print ...\n\n    -   ... the fourth element in `pp3`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution:\"}\n    print(pp3[4]) # or simply\n    \n    pp3[4]\n    ```\n    :::\n\n\n\n    -   ... elements 3 through 5.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution:\"}\n    pp3[3:5]\n    ```\n    :::\n\n\n\n    -   ... all elements.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution:\"}\n    pp3\n    ```\n    :::\n\n\n\n    -   ... elements 1, 3 **and** 5.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution:\"}\n    pp3[c(1, 3, 5)]\n    ```\n    :::\n\n\n\n3.  When working with large datasets, we often don't know whether an\n    element is in the vector to begin with, let alone its position. For\n    instance, if we wanted to check whether *they* is in `pp3` or not,\n    we could use the handy notation below, returning a `TRUE` or `FALSE`\n    value:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"they\" %in% pp3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\nAscertain whether the following items are in `pp3`:\n\n-   *him*\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution:\"}\n    \"him\" %in% pp3 # TRUE\n    ```\n    :::\n\n\n\n-   *you*\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution:\"}\n    \"you\" %in% pp3 # FALSE\n    ```\n    :::\n\n\n\n-   *it* and *them*\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution:\"}\n    c(\"it\", \"them\") %in% pp3 # TRUE TRUE\n    ```\n    :::\n\n\n\n-   *we*, *us* and *me*\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution:\"}\n    c(\"we\", \"us\", \"them\") %in% pp3 # FALSE FALSE TRUE\n    ```\n    :::\n\n\n\n4.  Once we are sure that an element is in the vector of interest,\n    another common problem that arises is finding its location. Luckily,\n    R has got us covered! The `which()` function returns the index of an\n    element.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(pp3 == \"they\") # Note the two equal signs == !\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n\nYou can read this notation as \"Which element in `pp3` is *they*?\". The\noutput suggests that is in position `6`. Note that the number obtained\ndepends on the order of elements you've chosen when creating `pp3`.\n\nNow, it's your turn: Find the locations of *it* and *them* in `pp3`!\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution:\"}\n# \"him\"\nwhich(pp3 == \"it\")\n\n# \"you\"\nwhich(pp3 == \"them\")\n```\n:::\n",
    "supporting": [
      "Vectors_Factors_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}