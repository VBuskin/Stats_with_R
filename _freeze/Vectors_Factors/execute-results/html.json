{
  "hash": "e24fde8731da6fad9e1e5cdf7ad46ee8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Vectors\"\nauthor: Vladimir Buskin\nformat:\n  html:\n    self-contained: true\n    theme: default\n    toc: true\n    number-sections: true\n    slide-number: true\n    incremental: false\n    slide-level: 3\n    scrollable: true\n    \neditor: visual\n---\n\n\n## Preparation\n\n::: callout-tip\n## Script\n\nYou can find the full R script associated with this unit\n[here](https://osf.io/jmych).\n:::\n\n## Recommended reading\n\n> @winter_statistics_2020: Chapter 1.1–1.9\n\nSuggested video tutorial:\n\n> [How to Create and Name Vectors in\n> R](https://www.youtube.com/watch?v=w5dOALbZ9HE) (DataCamp; 5min)\n\n## Word frequencies I\n\nYou are given the following token counts of English verb lemmas in the\nInternational Corpus of English.\n\n| Lemma | Frequency |\n|-------|-----------|\n| start | 418       |\n| enjoy | 139       |\n| begin | 337       |\n| help  | 281       |\n\nWhile this table is relatively small and easy to interpret, it is still\na good idea to supply readers with a simple visual representation of the\nfrequency distributions (e.g., a barplot.). Quite conveniently, R\nhappens to provide us with an abundance of plotting functions! In order\nto make use of them, all we need to do is communicate to R the data we\nwant to visualise. We can supply the data either\n\n1.  by **manually** listing all the elements of interest or\n\n2.  **automatically** by importing it from an existing spreadsheet file\n    (e.g., from Microsoft Excel).\n\nFor now, we will stick to option 1 and move on to option 2 in a later\nunit (cf. @sec-import).\n\n### Storing data in R\n\nTo create a two-dimensional plot, we will first need to generate two\nobjects in R: one for the individual lemmas and one for the frequency\ncounts.\n\nLet's start by combining the lemmas *start, enjoy, begin* and *help*\ninto an object `lemma` using R's `c()` function. Enter the following\nline into a new R script and click on **Run** (or simply press\nCtrl+Enter/Cmd+Enter).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlemma <- c(\"start\", \"enjoy\", \"begin\", \"help\")\n```\n:::\n\n\nTo make sure this worked, we can apply the `print()` function to `lemma`\nto view the elements it holds:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(lemma)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"start\" \"enjoy\" \"begin\" \"help\" \n```\n\n\n:::\n:::\n\n\nNaturally, it is also possible to combine numeric information with\n`c()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrequency <- c(418, 139, 337, 281)\n```\n:::\n\n\nThe `print()` functions allows us to inspect the contents of\n`frequency`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(frequency)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 418 139 337 281\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"When do I use quotation marks?\" collapse=\"true\"}\nLetters and numbers represent two distinct data types in R. Anything\nthat should be understood as a simple sequence of letters must be\nenclosed by quotation marks `\"...\"`. A linguistic item such as *start*\nwill be will be evaluated as a **string** if it's encoded as `\"start\"`.\n\n**Numbers** (or **integers**), by contrast, appear without quotation\nmarks.\n:::\n\n### Creating the barplot\n\nOur linguistic data is now stored in two **variables** `lemma` and\n`frequency`, which you can conceptualise as virtual container-like\nobjects. These 'containers' are now showing in the **Environment** tab\nin the top right corner of your RStudio interface.\n\nThe combination of categorical labels and numeric information renders\nour data ideally suited for a barplot. R's most basic barplot function\n(which is, unsurprisingly, called `barplot()`) needs at the very least\n...\n\n-   a `height` argument, i.e., our y-axis values and\n\n-   a `names.arg` argument, i.e., our x-axis labels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(frequency, names.arg = lemma)\n```\n\n::: {.cell-output-display}\n![](Vectors_Factors_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nAfter some tinkering, our plot looks more presentable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(frequency, names.arg = lemma, \n        main = \"Frequency of Lemmas\", # title\n        xlab = \"Lemmas\",  # label for x-axis\n        ylab = \"Frequency\", # label for y-axis\n        col = \"steelblue\") # color\n```\n\n::: {.cell-output-display}\n![](Vectors_Factors_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-tip title=\"What does '#' mean? On comments in R\" collapse=\"true\"}\nIn R, everything followed by the hashtag `#` will be interpreted as a\ncomment and won't be evaluated by the R compiler. While comments don't\naffect the output of our code in the slightest, they are **crucial** to\nany kind of programming project.\n\nAdding prose annotations will make your code not only easier to\nunderstand for others but also for your future self. Poor documentation\nis a common, yet unnecessary source of frustration for all parties\ninvolved ...\n\n![](comments_meme.png){fig-align=\"center\" width=\"60%\"}\n:::\n\nIn RStudio, you now have the option to save the plot to your computer.\nOnce the figure has appeared in your \"Plots\" panel, you can click on\n\"Export\" in the menu bar below and proceed to choose the desired output\nformat and file directory.\n\n### Essential R concepts\n\nThe example above demonstrates one of the most important data structures\nin R: **vectors**. They form the cornerstone of various more complex\nobjects such as data frames, and are essential to handling large data\nsets (e.g., corpora). And yet, vectors are very simple in that they are\nmerely one-dimensional sequences of characters or numbers — no more, no\nless.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(lemma)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"start\" \"enjoy\" \"begin\" \"help\" \n```\n\n\n:::\n\n```{.r .cell-code}\nprint(frequency)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 418 139 337 281\n```\n\n\n:::\n:::\n\n\nThe individual elements in these two vectors are not randomly jumbling\naround in virtual space, but are in fact following a clear order. Each\nelement comes with an \"ID\" (or **index**), by which it can be accessed.\nFor example, if we want to print the first lemma in our `lemma`\nvariable, we append square brackets `[ ]` to it. This will allow us to\n**subset** it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlemma[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"start\"\n```\n\n\n:::\n:::\n\n\nSimilarly, we can subset `frequency` according to, for example, its\nthird element:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrequency[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 337\n```\n\n\n:::\n:::\n\n\nIt is also possible to obtain entire ranges of elements, such as\neverything from the second to the fourth element:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrequency[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 139 337 281\n```\n\n\n:::\n:::\n\n\n## Exercises\n\n::: callout-tip\n## Solutions\n\nYou can find the solutions to the exercises\n[here](https://osf.io/967hj).\n:::\n\n::: {#exr-v-1}\nCreate a vector that lists the third person personal pronouns of\n    English (subject and object forms). Store them in a variable `pp3`.\n::: \n\n::: {#exr-v-2}\nNow print ...\n\n    -   ... the fourth element in `pp3`.\n\n    -   ... elements 3 through 5.\n\n    -   ... all elements.\n\n    -   ... elements 1, 3 **and** 5.\n\n:::\n\n::: {#exr-v-3}\nWhen working with large datasets, we often don't know whether an\n    element is in the vector to begin with, let alone its position. For\n    instance, if we wanted to check whether *they* is in `pp3` or not,\n    we could use the handy notation below, returning a `TRUE` or `FALSE`\n    value:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"they\" %in% pp3\n```\n:::\n\n\nAscertain whether the following items are in `pp3`:\n\n-   *him*\n\n-   *you*\n\n-   *it* and *them*\n\n-   *we*, *us* and *me*\n\n:::\n\n::: {#exr-v-4}\n\nOnce we are sure that an element is in the vector of interest,\n    another common problem that arises is finding its location. In this\n    case, we can use `which()` to return the index of an element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(pp3 == \"they\")\n```\n:::\n\n\nYou can read the code above as \"Which element in `pp3` is *they*?\". Note\nthat the index number depends on the order of elements you've chosen\nwhen creating `pp3`.\n\nFind the locations of *it* and *them* in `pp3`!\n\n:::\n\n::: {#exr-v-5}\n\nConsider the vector `numbers`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- c(500:1000)\n```\n:::\n\n\n-   What does the following code do? How does the output change when you\n    subset `numbers` according to this expression?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(numbers > 600)\n```\n:::\n\n\n-   Describe the output of these code chunks:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers[numbers != 500]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers[numbers > 500 & numbers < 550]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers[numbers < 510 | numbers > 990]\n```\n:::\n\n\n:::",
    "supporting": [
      "Vectors_Factors_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}