{
  "hash": "19cc07586c9e70f1babbe76470a4cf82",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Vectors\"\nauthor: Vladimir Buskin\nformat:\n  html:\n    self-contained: false\n    theme: default\n    toc: true\n    number-sections: true\n    slide-number: true\n    incremental: false\n    slide-level: 3\n    scrollable: true\n    \neditor: visual\n---\n\n\n## Recommended reading\n\n> @winter_statistics_2020: Chapter 1.1–1.9\n\nSuggested video tutorial:\n\n> [How to Create and Name Vectors in\n> R](https://www.youtube.com/watch?v=w5dOALbZ9HE) (DataCamp; 5min)\n\n## Word frequencies I\n\nYou are given the following token counts of English verb lemmas in the\nInternational Corpus of English:\n\n| Lemma | Frequency |\n|-------|-----------|\n| start | 418       |\n| enjoy | 139       |\n| begin | 337       |\n| help  | 281       |\n\nIt is always a good idea to visualise frequency data in some way. Quite\nconveniently, R happens to provide us with an abundance of plotting\nfunctions. To create a two-dimensional plot, we need to generate two\nobjects in R: one for the individual lemmas and one for the frequency\ncounts.\n\nLet's combine the lemmas *start, enjoy, begin* and *help* using R's\n`c()` function and store them in an object `lemma`. Enter the following\nline into a new R script and click on **Run** (or simply press\nCtrl+Enter/Cmd+Enter).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlemma <- c(\"start\", \"enjoy\", \"begin\", \"help\")\n```\n:::\n\n\nWe can now do the same for the frequency information:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrequency <- c(418, 139, 337, 281)\n```\n:::\n\n\n::: {.callout-tip title=\"When do I use quotation marks?\" collapse=\"true\"}\nLetters and numbers represent two distinct data types in R. Anything\nthat should be understood as a simple sequence of letters must be\nenclosed by quotation marks `\"...\"`. A linguistic item such as *start*\nwill be will be evaluated as a **string** if it's encoded as `\"start\"`.\n\n**Numbers** (or **integers**), by contrast, appear without quotation\nmarks.\n:::\n\nOur linguistic data is now stored in two **variables** `lemma` and\n`frequency`, which you can conceptualise as virtual container-like\nobjects. These 'containers' are now showing in the **Environment** tab\nin the top right corner of your RStudio interface.\n\nThe combination of categorical labels and numeric information renders\nour data ideally suited for a barplot. R's most basic barplot function\n(which is, unsurprisingly, called `barplot()`) needs at the very least\n...\n\n-   a `height` argument, i.e., our y-axis values and\n\n-   a `names.arg` argument, i.e., our x-axis labels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(frequency, names.arg = lemma)\n```\n\n::: {.cell-output-display}\n![](Vectors_Factors_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nAfter some tinkering, our plot looks more presentable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(frequency, names.arg = lemma, \n        main = \"Frequency of Lemmas\", # title\n        xlab = \"Lemmas\",  # label for x-axis\n        ylab = \"Frequency\", # label for y-axis\n        col = \"steelblue\") # color\n```\n\n::: {.cell-output-display}\n![](Vectors_Factors_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-tip title=\"What does '#' mean? On comments in R\" collapse=\"true\"}\nIn R, everything followed by the hashtag `#` will be interpreted as a\ncomment and won't be evaluated by the R compiler. While comments don't\naffect the output of our code in the slightest, they are **crucial** to\nany kind of programming project.\n\nAdding prose annotations will make your code not only easier to\nunderstand for others but also for your future self. Poor documentation\nis a common, yet unnecessary source of frustration for all parties\ninvolved ...\n\n![](comments_meme.png){fig-align=\"center\" width=\"60%\"}\n:::\n\nIn RStudio, you now have the option to save the plot to your computer.\nOnce the figure has appeared in your \"Plots\" panel, you can click on\n\"Export\" in the menu bar below and proceed to choose the desired output\nformat and file directory.\n\n## Essential R concepts\n\nThe example above demonstrates one of the most important data structures\nin R: **Vectors**. They form the cornerstone of various more complex\nobjects such as data frames, and are essential to handling large data\nsets (e.g., corpora). And yet, vectors are very simple in that they are\nmerely one-dimensional sequences of characters or numbers — no more, no\nless.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(lemma)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"start\" \"enjoy\" \"begin\" \"help\" \n```\n\n\n:::\n\n```{.r .cell-code}\nprint(frequency)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 418 139 337 281\n```\n\n\n:::\n:::\n\n\nThe individual elements in these two vectors are not randomly jumbling\naround in virtual space, but are in fact following a clear order. Each\nelement comes with an \"ID\" (or **index**), by which it can be accessed.\nFor example, if we want to print the first lemma in our `lemma`\nvariable, we append square brackets `[ ]` to it. This will allow us to\n**subset** it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlemma[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"start\"\n```\n\n\n:::\n:::\n\n\nSimilarly, we can subset `frequency` according to, for example, its\nthird element:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrequency[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 337\n```\n\n\n:::\n:::\n\n\nIt is also possible to obtain entire ranges of elements, such as\neverything from the second to the fourth element:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrequency[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 139 337 281\n```\n\n\n:::\n:::\n\n\n## Exercises\n\n1.  Create a vector that lists the third person personal pronouns of\n    English (subject and object forms). Store them in a variable `pp3`.\n\n2.  Now print ...\n\n    -   ... the fourth element in `pp3`.\n\n    -   ... elements 3 through 5.\n\n    -   ... all elements.\n\n    -   ... elements 1, 3 **and** 5.\n\n3.  When working with large datasets, we often don't know whether an\n    element is in the vector to begin with, let alone its position. For\n    instance, if we wanted to check whether *they* is in `pp3` or not,\n    we could use the handy notation below, returning a `TRUE` or `FALSE`\n    value:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"they\" %in% pp3\n```\n:::\n\n\nAscertain whether the following items are in `pp3`:\n\n-   *him*\n\n-   *you*\n\n-   *it* and *them*\n\n-   *we*, *us* and *me*\n\n4.  Once we are sure that an element is in the vector of interest,\n    another common problem that arises is finding its location. In this\n    case, we can use `which()` to return the index of an element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(pp3 == \"they\")\n```\n:::\n\n\nYou can read the code above as \"Which element in `pp3` is *they*?\". Note\nthat the index number depends on the order of elements you've chosen\nwhen creating `pp3`.\n\nFind the locations of *it* and *them* in `pp3`!\n\n5.  Consider the vector `numbers`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- c(500:1000)\n```\n:::\n\n\n-   What does the following code do? How does the output change when you\n    subset `numbers` according to this expression?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(numbers > 600)\n```\n:::\n\n\n-   Describe the output of these code chunks:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers[numbers != 500]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers[numbers > 500 & numbers < 550]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers[numbers < 510 | numbers > 990]\n```\n:::\n",
    "supporting": [
      "Vectors_Factors_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}