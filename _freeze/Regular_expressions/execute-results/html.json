{
  "hash": "e9038836f7f0b5de31dd302bdcf40eb9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Regular expressions\"\nauthor: Vladimir Buskin, Thomas Brunner\nformat:\n  html:\n    self-contained: true\n    theme: default\n    toc: true\n    number-sections: true\n    slide-number: true\n    incremental: false\n    slide-level: 3\n    scrollable: true\n    \neditor: visual\n---\n\n\n## Regular expressions\n\n**Regular expressions** (or 'regex') help us find more complex patterns\nin strings of text. Suppose we are interested in finding all\ninflectional forms of the lemma PROVIDE in a corpus, i.e., *provide,\nprovides, providing* and *provided*. Insteading of searching for all\nforms individually, we can construct a regular expression of the form\n\n$$\n\\text{provide(s | ing | ed)?}\n$$ which can be read as 'Match the sequence of letters \\<provide\\> as\nwell as when it is optionally followed by the letters \\<s\\> or \\<ing\\>\nor \\<ed\\>'. Notice how optionality is signified by the '?' operator and\nalternatives by '\\|'.\n\nTo activate regular expression in a KWIC query, simply set the\n`valuetype` argument to `\"regex\"`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Query the corpus\nkwic_provide3 <- kwic(ICE_GB,\n                     pattern = \"provide(s|ing|ed)?\",\n                     valuetype = \"regex\", # query format\n                     window = 20)\n\n                     \n\n# View output in separate window\n#View(kwic_provide)\n```\n:::\n\n\nThe number of hits has more than doubled. However, upon closer\ninspection, we'll notice a number of false positives (e.g.,\n*providential*).\n\n\n::: {.cell}\n\n:::\n\n\n## A RegEx Cheatsheet\n\n### Basic functions\n\n| **Command** | **Definition** | **Example** | **Finds** |\n|-------------|----------------|-------------|-----------|\n|             |                | `python`    | *python*  |\n| `.`         | Any character  | `.ython`    | *aython, bython...* |\n\n### Character classes and alternatives\n\n| **Command**          | **Definition**                                     | **Example**   | **Finds**                 |\n|----------------------|---------------------------------------------------|---------------|---------------------------|\n| `[abc]`              | Class of characters                               | `[jp]ython`   | *jython, python*          |\n| `[ ^pP]`             | Excluded class of characters                      | `[^pP]ython`  | everything but *python, Python* |\n| `(...|...)`          | Alternatives linked by logical operator `or`      | `P(ython|eter)` | *Python, Peter*           |\n\n### Pre-defined character classes\n\n| **Command**  | **Definition**                   | **Example** | **Finds**               |\n|--------------|----------------------------------|-------------|-------------------------|\n| `\\w`         | All alphanumeric characters      |             | A-Z, a-z, 0-9           |\n| `\\W`         | All non-alphanumeric characters  |             | everything but A-Z, a-z, 0-9 |\n| `\\d`         | All decimal numbers              |             | 0-9                     |\n| `\\D`         | Everything which is not a decimal number |       | everything but 0-9      |\n| `\\s`         | Empty space                      |             |                         |\n\n### Quantifiers\n\n| **Command**  | **Definition**                                             | **Example**    | **Finds**                              |\n|--------------|------------------------------------------------------------|----------------|----------------------------------------|\n| `?`          | One or zero instances of the preceding symbol              | `Py?thon`      | *Python, Pthon*                        |\n| `*`          | No matter how many times â€” also zero                       | `Py*thon`      | *Python, Pthon, Pyyyython...*          |\n|              |                                                            | `P[Yy]*thon`   | *Python, Pthon, PyYYython...*          |\n| `+`          | No matter how many times but at least once                 | `Py+thon`      | *Python, Pyyython, Pyyyython*          |\n| `{1,3}`      | `{min, max}`                                               | `Py{1,3}thon`  | *Python, Pyython, Pyyython*            |\n\n## Tasks\n\n1. Find all labels of months!\n2. Write an elegant regular expression which finds *sing*, *sang* and *sung*.\n3. Find all four-digit numbers in the corpus!\n4. Write an elegant regular expression which finds all inflectional forms of *swim*!",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}