{
  "hash": "037cfb09f10337df4f70728a6f6cfde5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Regular expressions\"\nauthor: Vladimir Buskin, Thomas Brunner\nformat:\n  html:\n    self-contained: true\n    theme: default\n    toc: true\n    number-sections: true\n    slide-number: true\n    incremental: false\n    slide-level: 3\n    scrollable: true\n    \neditor: visual\n---\n\n\n## Regular expressions\n\n**Regular expressions** (or 'regex') help us find more complex patterns\nin strings of text. Suppose we are interested in finding all\ninflectional forms of the lemma PROVIDE in a corpus, i.e., *provide,\nprovides, providing* and *provided*. Insteading of searching for all\nforms individually, we can construct a regular expression of the form\n\n$$\n\\text{provid(es | ing | ed)?}\n$$which can be read as 'Match the sequence of letters \\<provide\\> as\nwell as when it is optionally followed by the letters \\<s\\> or \\<ing\\>\nor \\<ed\\>'. Notice how optionality is signified by the '?' operator and\nalternatives by '\\|'.\n\nTo activate regular expression in a KWIC query, simply set the\n`valuetype` argument to `\"regex\"`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load library and corpus\nlibrary(quanteda)\nICE_GB <- readRDS(\"ICE_GB.RDS\")\n\n# Perform query\nkwic_provide <- kwic(ICE_GB,\n                     phrase(\"provid(es|ing|ed)?\"),\n                     valuetype = \"regex\",\n                     window = 20)\n```\n:::\n\n\nThe number of hits has more than doubled. However, upon closer\ninspection, we'll notice a few false positives, namely *providential,\nprovider* and *providers*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(kwic_provide$keyword)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n      provid      provide     provided     Provided    Provident providential \n           1          165          118            5            1            1 \n    provider    providers     provides    providing    Providing \n           1            3           72           52            1 \n```\n\n\n:::\n:::\n\n\nThere are two ways to handle this:\n\n1.  Refine the search expression further to only match those cases of\n    interest.\n2.  Manually sort out irrelevant cases during annotation in your\n    spreadsheet software.\n\nAs a rule of thumb, you should consider improving your search expression\nif you receive hundreds or even thousands of false hits. If there are\nonly a couple of false positives, it's usually easier to simply mark\nthem as \"irrelevant\" in your spreadsheet.\n\n::: callout-caution\n## Task\n\nHow could you refine the search expression for PROVIDE to get rid of the\nirrelevant cases? Consult the RegEX Cheatsheet below!\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution:\"}\n# Add word boundary with \\\\b\nkwic_provide2 <- kwic(ICE_GB,\n                     phrase(\"\\\\bprovid(e|es|ing|ed)\\\\b\"),\n                     valuetype = \"regex\",\n                     window = 20)\n\ntable(kwic_provide2$keyword)\n```\n:::\n\n:::\n\n## A RegEx Cheatsheet\n\n### Basic functions\n\n| **Command** | **Definition** | **Example** | **Finds**           |\n|-------------|----------------|-------------|---------------------|\n|             |                | `python`    | *python*            |\n| `.`         | Any character  | `.ython`    | *aython, bython...* |\n\n### Character classes and alternatives\n\n| **Command** | **Definition**                               | **Example**     | **Finds**                       |\n|-----------------|---------------------|-----------------|-----------------|\n| `[abc]`     | Class of characters                          | `[jp]ython`     | *jython, python*                |\n| `[ ^pP]`    | Excluded class of characters                 | `[^pP]ython`    | everything but *python, Python* |\n| `(...|...)` | Alternatives linked by logical operator `or` | `P(ython|eter)` | *Python, Peter*                 |\n\n### Pre-defined character classes\n\n| **Command** | **Definition**                           | **Example**    | **Finds**                        |\n|-----------------|--------------------|-----------------|-----------------|\n| `\\\\w`       | All alphanumeric characters              |                | A-Z, a-z, 0-9                    |\n| `\\\\W`       | All non-alphanumeric characters          |                | everything but A-Z, a-z, 0-9     |\n| `\\\\d`       | All decimal numbers                      |                | 0-9                              |\n| `\\\\D`       | Everything which is not a decimal number |                | everything but 0-9               |\n| `\\\\s`       | Empty space                              |                |                                  |\n| `\\\\b`       | Word boundary                            | `\\\\bpython\\\\b` | Matches *python* as a whole word |\n\n### Quantifiers\n\n| **Command** | **Definition**                                | **Example**   | **Finds**                     |\n|-----------------|---------------------|-----------------|-----------------|\n| `?`         | One or zero instances of the preceding symbol | `Py?thon`     | *Python, Pthon*               |\n| `*`         | No matter how many times â€” also zero          | `Py*thon`     | *Python, Pthon, Pyyyython...* |\n|             |                                               | `P[Yy]*thon`  | *Python, Pthon, PyYYython...* |\n| `+`         | No matter how many times but at least once    | `Py+thon`     | *Python, Pyyython, Pyyyython* |\n| `{1,3}`     | `{min, max}`                                  | `Py{1,3}thon` | *Python, Pyython, Pyyython*   |\n\n## Exercises\n\n1.  Find all labels of months!\n2.  Write an elegant regular expression which finds *sing*, *sang* and\n    *sung*.\n3.  Find all four-digit numbers in the corpus!\n4.  Write an elegant regular expression which finds all inflectional\n    forms of *swim*!\n",
    "supporting": [
      "Regular_expressions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}