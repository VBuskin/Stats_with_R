---
title: "Querying a corpus"
author: Vladimir Buskin
format:
  html:
    self-contained: false
    theme: default
    toc: true
    number-sections: true
    slide-number: true
    incremental: false
    slide-level: 3
    scrollable: true
    
editor: visual
---

## Introduction

This section offers a short introduction to corpus queries in R. Our
goal will be to obtain data on the genitive alternation in British
English. To this end, we will rely on the British component of the
International Corpus of English (ICE-GB).

## Preparation

### Directory structure

In order for R to be able to recognise the data, it is crucial to set up
the working directory correctly.

1.  Make sure your R-script **and** the corpus (e.g., 'ICE-GB') are
    stored in the **same folder**.
2.  In RStudio, now navigate to `Session` \> `Set working directory` \>
    `To Source File Location`. This ensures that the folder where you
    have placed your R-script will function as your working directory
    until you close RStudio again. To see your working directory in your
    files pane, click on `Files` \> `'Blue wheel symbol'` \>
    `Go to working directory`.

### Installing and loading packages (move to earlier session)

Packages expand the basic functionality of R by providing numerous
quality-of-life improvements that not only considerably simplify common
data wrangling tasks but which also provide frameworks for
state-of-the-art methods for statistical analysis and natural language
processing (NLP).

In order to install a package, you navigate to `Packages` \> `Install`
and verify that the pop-up window says
`Install from: Repository (CRAN)`. You can now type in the name of the
package you would like to install under `Packages`.

**Task**: Install the `tidyverse` and `quanteda` packages!

Once the installation has been completed, you can proceed to load the
libraries using the code below. You can ignore the warning messages.

```{r, echo = TRUE}

library(tidyverse)
library(quanteda)
```

```{r, echo = FALSE}

library(kableExtra)

```

Remember that you will have to reload these libraries whenever you start
a new R session (i.e., open RStudio).

## Loading the corpus

After specifying the working directory and loading the libraries we will
need, we can read in the corpus files into a corpus object in R.

First, simply copy-paste the following code chunk at the beginning of
your R-script. Once you run it, it will load the function `read_GB()`
into R's working memory (it should now appear in the `Environment`
tab!). This function will automatically handle the entire reading-in
process.

To now get all corpus files into R, all we have to do is call the
function:

```{r, echo = TRUE, eval = T}


ICE_GB <- readRDS("ICE_GB.RDS")

```

If you encounter error messages, make sure you followed steps 1 and 2
above.

## Concordancing

```{r}
library(quanteda)
library(tidyverse)

# Load corpus
ICE_GB <- readRDS("ICE_GB.RDS")
```

#### Basic use

-   Concordances

```{r, echo = T, output = T}

# Query the corpus
query1 <- kwic(ICE_GB, pattern = "provid(e|es|ing|ed)", valuetype = "regex")

query1 %>%
  as_tibble() %>% 
  count(keyword)

# Print first six lines to console
#head(as_tibble(kwic_provide))

# View output in separate window
#View(kwic_provide)
```

```{r, echo = F}

query1 %>% 
  head() %>% 
  kbl() %>% 
  kable_classic(full_width = F, html_font = "Cambria")

```

#### Increase search window

```{r, eval = FALSE}

# Query the corpus
kwic_provide2 <- kwic(tokens(ICE_GB_corpus),
                     pattern = "provide",
                     window = 20) # choose window size

# View output in separate window
#View(kwic_provide)
```

```{r, echo = F, eval = FALSE}

kwic_provide2 %>% 
  head() %>% 
  kbl() %>% 
  kable_classic(full_width = F, html_font = "Cambria")

```

#### Regular expressions

**Regular expressions** (or 'regex') help us find more complex patterns
in strings of text. Suppose we are interested in finding all
inflectional forms of the lemma PROVIDE in a corpus, i.e., *provide,
provides, providing* and *provided*. Insteading of searching for all
forms individually, we can construct a regular expression of the form

$$
\text{provide(s | ing | ed)?}
$$ which can be read as 'Match the sequence of letters \<provide\> as
well as when it is optionally followed by the letters \<s\> or \<ing\>
or \<ed\>'. Notice how optionality is signified by the '?' operator and
alternatives by '\|'.

To activate regular expression in a KWIC query, simply set the
`valuetype` argument to `"regex"`:

```{r, eval = FALSE}

# Query the corpus
kwic_provide3 <- kwic(ICE_GB,
                     pattern = "provide(s|ing|ed)?",
                     valuetype = "regex", # query format
                     window = 20)

                     

# View output in separate window
#View(kwic_provide)
```

The number of hits has more than doubled. However, upon closer
inspection, we'll notice a number of false positives (e.g.,
*providential*).

```{r, echo = F, eval = FALSE}

kwic_provide3 %>% 
  head() %>% 
  kbl() %>% 
  kable_classic(full_width = T, html_font = "Cambria")

```

### RegEx: A Cheatsheet

### Example usage

### Exporting the results
