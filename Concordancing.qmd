---
title: "Querying a corpus"
author: Vladimir Buskin
format:
  html:
    self-contained: true
    theme: default
    toc: true
    number-sections: true
    slide-number: true
    incremental: false
    slide-level: 3
    scrollable: true
    
editor: visual
---

## Using the `QuantedaApp`

### Installation

Installation and usage instructions are available in this [GitHub
repository](https://github.com/VBuskin/quanteda_app).

## Using the `quanteda` package in R

### Preparation

In order for R to be able to recognise the data, it is crucial to set up
the working directory correctly.

1.  Make sure your R-script **and** the corpus (e.g., 'ICE-GB') are
    stored in the **same folder**.

2.  In RStudio, now navigate to `Session` \> `Set working directory` \>
    `To Source File Location`. This ensures that the folder where you
    have placed your R-script will function as your working directory
    until you close RStudio again.

To see your working directory in your files pane, click on `Files` \>
`'Blue wheel symbol'` \> `Go to working directory`.

### Loading the corpus

After specifying the working directory and loading the libraries we will
need, we can read in the corpus files into a corpus object in R.

First, simply copy-paste the following code chunk at the beginning of
your R-script. Once you run it, it will load the function `read_GB()`
into R's working memory (it should now appear in the `Environment`
tab!). This function will automatically handle the entire reading-in
process.

To now get all corpus files into R, all we have to do is call the
function:

```{r, echo = TRUE, eval = T}


ICE_GB <- readRDS("ICE_GB.RDS")

```

If you encounter error messages, make sure you followed steps 1 and 2
above.

### Concordancing

```{r}
library(quanteda)
library(tidyverse)
library(kableExtra)

# Load corpus
ICE_GB <- readRDS("ICE_GB.RDS")
```

-   Concordances

```{r, echo = T, output = T}

# Query the corpus
query1 <- kwic(ICE_GB, pattern = "provid(e|es|ing|ed)", valuetype = "regex")

query1 %>%
  as_tibble() %>% 
  count(keyword)

# Print first six lines to console
#head(as_tibble(kwic_provide))

# View output in separate window
#View(kwic_provide)
```

```{r, echo = F}

query1 %>% 
  head() %>% 
  kbl() %>% 
  kable_classic(full_width = F, html_font = "Cambria")

```

#### Increase search window

```{r, eval = FALSE}

# Query the corpus
kwic_provide2 <- kwic(tokens(ICE_GB_corpus),
                     pattern = "provide",
                     window = 20) # choose window size

# View output in separate window
#View(kwic_provide)
```

```{r, echo = F, eval = FALSE}

kwic_provide2 %>% 
  head() %>% 
  kbl() %>% 
  kable_classic(full_width = F, html_font = "Cambria")

```

## Regular expressions

**Regular expressions** (or 'regex') help us find more complex patterns
in strings of text. Suppose we are interested in finding all
inflectional forms of the lemma PROVIDE in a corpus, i.e., *provide,
provides, providing* and *provided*. Insteading of searching for all
forms individually, we can construct a regular expression of the form

$$
\text{provide(s | ing | ed)?}
$$ which can be read as 'Match the sequence of letters \<provide\> as
well as when it is optionally followed by the letters \<s\> or \<ing\>
or \<ed\>'. Notice how optionality is signified by the '?' operator and
alternatives by '\|'.

To activate regular expression in a KWIC query, simply set the
`valuetype` argument to `"regex"`:

```{r, eval = FALSE}

# Query the corpus
kwic_provide3 <- kwic(ICE_GB,
                     pattern = "provide(s|ing|ed)?",
                     valuetype = "regex", # query format
                     window = 20)

                     

# View output in separate window
#View(kwic_provide)
```

The number of hits has more than doubled. However, upon closer
inspection, we'll notice a number of false positives (e.g.,
*providential*).

```{r, echo = F, eval = FALSE}

kwic_provide3 %>% 
  head() %>% 
  kbl() %>% 
  kable_classic(full_width = T, html_font = "Cambria")

```

### Example usage

### Exporting the results
